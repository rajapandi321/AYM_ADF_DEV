{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "Az-adf-ecomm-v1-v2"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/loyalty_member')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "Select\n  id,\n  user_id,\n  tenant_id,\n  loyalty_member_id,\n  loyalty_id,\n  created_at,\n  updated_at\nfrom spree_loyalty_members;"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_USER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "loyalty_member"
								}
							}
						]
					},
					{
						"name": "Lookup1",
						"type": "Lookup",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [
							{
								"activity": "Copy data1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": "DO $$\r\nDECLARE\r\n    max_id INT;\r\nBEGIN\r\n    -- Step 1: Get the maximum id from the 'order' table\r\n    SELECT MAX(id) INTO max_id FROM \"loyalty_member\";\r\n    \r\n    -- Step 2: Alter the sequence to restart with max_id + 1\r\n    EXECUTE 'ALTER SEQUENCE loyalty_member_id_seq RESTART WITH ' || (max_id + 1000);\r\nEND $$;\r\nSelect 'Altering Sequence ID' as Update;",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "DS_V2_USER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "loyalty_member"
								}
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "User DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/loyalty_member_cdc')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Lookup1",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": "select max(updated_at) as max_updated_date from loyalty_member;",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "DS_V2_USER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "loyalty_member"
								}
							}
						}
					},
					{
						"name": "Set variable1",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Lookup1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "max_updated_date",
							"value": {
								"value": "@activity('Lookup1').output.firstRow.max_updated_date",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Set variable1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": {
									"value": "Select\n  id,\n  user_id,\n  tenant_id,\n  loyalty_member_id,\n  loyalty_id,\n  created_at,\n  updated_at\nfrom spree_loyalty_members\nwhere updated_at > '@{variables('max_updated_date')}';",
									"type": "Expression"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobStorageWriteSettings"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_Intermiadate_Result",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Copy data1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_loyalty_member_cdc",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source1": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Delete1",
						"type": "Delete",
						"dependsOn": [
							{
								"activity": "Data flow1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "DS_Intermiadate_Result",
								"type": "DatasetReference",
								"parameters": {}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobStorageReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"max_updated_date": {
						"type": "String"
					}
				},
				"folder": {
					"name": "User DB CDC"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/nutritional_facts')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "WITH json_to_extract AS\n(\n       SELECT id,\n              quantity_en AS quantity,\n              product_id,\n              created_at,\n              updated_at,\n              quantity_ar,\n              nutrients :: jsonb AS json_data\n       FROM   spree_nutritional_facts )\nSELECT    id,\n          quantity,\n          quantity_ar,\n          product_id,\n          calories,\n          total_fat,\n          saturated_fat,\n          trans_fat,\n          cholesterol,\n          total_carbohydrates,\n          sugar,\n          dietary_fiber,\n          protein,\n          salt,\n          sodium,\n          iron,\n          calcium,\n          vitamin_a,\n          vitamin_c,\n          vitamin_d,\n          ph,\n          created_at,\n          updated_at\nFROM      json_to_extract\nLEFT JOIN lateral\n          (\n                 Select ( Regexp_matches( json_data :: text, 'calories:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]            AS calories,\n                        ( regexp_matches( json_data :: text, 'total_fat:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]           AS total_fat,\n                        ( regexp_matches( json_data :: text, 'saturated_fat:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]       AS saturated_fat,\n                        ( regexp_matches( json_data :: text, 'trans_fat:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]           AS trans_fat,\n                        ( regexp_matches( json_data :: text, 'cholesterol:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]         AS cholesterol,\n                        ( regexp_matches( json_data :: text, 'total_carbohydrates:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1] AS total_carbohydrates,\n                        ( regexp_matches( json_data :: text, 'sugar:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]               AS sugar,\n                        ( regexp_matches( json_data :: text, 'fiber:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]               AS dietary_fiber,\n                        ( regexp_matches( json_data :: text, 'protein:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]             AS protein,\n                        ( regexp_matches( json_data :: text, 'salt:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]                AS salt,\n                        ( regexp_matches( json_data :: text, 'sodium:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]              AS sodium,\n                        ( regexp_matches( json_data :: text, 'iron:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]                AS iron,\n                        ( regexp_matches( json_data :: text, 'calcium:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]             AS calcium,\n                        ( regexp_matches( json_data :: text, 'vitamin_a:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]           AS vitamin_a,\n                        ( regexp_matches( json_data :: text, 'vitamin_c:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]           AS vitamin_c,\n                        ( regexp_matches( json_data :: text, 'vitamin_d:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]           AS vitamin_d,\n                        ( regexp_matches( json_data :: text, 'ph:\\s*([\\d.]+)(?:\\s*(kcal|g|mg))?' ) ) [1]                  AS ph ) AS nutrient_values\nON        true\nORDER BY  id ASC;"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "product_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "product_id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "quantity",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "quantity",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "quantity_ar",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "quantity_ar",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										}
									},
									{
										"source": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										}
									},
									{
										"source": {
											"name": "calories",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "calories",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "total_fat",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "total_fat",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "saturated_fat",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "saturated_fat",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "trans_fat",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "trans_fat",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "cholesterol",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "cholesterol",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "total_carbohydrates",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "total_carbohydrates",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "sugar",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "sugar",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "dietary_fiber",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "dietary_fiber",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "protein",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "protein",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "salt",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "salt",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "sodium",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "sodium",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "iron",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "iron",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "calcium",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "calcium",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "vitamin_a",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "vitamin_a",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "vitamin_c",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "vitamin_c",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "vitamin_d",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "vitamin_d",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "ph",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "ph",
											"type": "String",
											"physicalType": "character varying"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_PRODUCT_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "nutritional_facts"
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Product DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/offline_product')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "SELECT id,\n\tCOALESCE(sku, '') AS sku,\n       COALESCE(Cast(price AS DOUBLE PRECISION),0) as price,\n       created_at,\n       updated_at,\n\tCOALESCE(name_en, '') AS name,\n       1 AS country_id,\n       1 AS order\nFROM   spree_custom_products;"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "name",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "name",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "sku",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "sku",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "price",
											"type": "Double",
											"physicalType": "double precision"
										},
										"sink": {
											"name": "price",
											"type": "Double",
											"physicalType": "double precision"
										}
									},
									{
										"source": {
											"name": "country_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "country_id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										}
									},
									{
										"source": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_PRODUCT_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "offline_product"
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Product DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/offline_product_barcode')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "SELECT \r\n    id AS offline_product_id,\r\n    CASE \r\n        WHEN (barcode_element ~ E'^\\\\d+$') THEN CAST(barcode_element AS BIGINT)\r\n        ELSE -1\r\n    END AS barcode,\r\n    1 AS \"order\"\r\nFROM   \r\n    spree_custom_products\r\nCROSS JOIN LATERAL unnest(barcodes) AS barcode_element\r\nORDER BY \r\n    id DESC;"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "barcode",
											"type": "Int64",
											"physicalType": "bigint"
										},
										"sink": {
											"name": "barcode",
											"type": "Int64",
											"physicalType": "bigint"
										}
									},
									{
										"source": {
											"name": "offline_product_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "offline_product_id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "order",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "order",
											"type": "Int32",
											"physicalType": "integer"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_PRODUCT_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "offline_product_barcode"
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Product DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/offline_product_cdc')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Lookup1",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": "select max(updated_at) as max_updated_date from offline_product;",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "DS_V2_PRODUCT_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "offline_product"
								}
							}
						}
					},
					{
						"name": "Set variable1",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Lookup1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "max_updated_date",
							"value": {
								"value": "@activity('Lookup1').output.firstRow.max_updated_date",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Set variable1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": {
									"value": "SELECT id,\r\n\tCOALESCE(sku, '') AS sku,\r\n       COALESCE(Cast(price AS DOUBLE PRECISION),0) as price,\r\n       created_at,\r\n       updated_at,\r\n\tCOALESCE(name_en, '') AS name,\r\n       1 AS country_id,\r\n       1 AS order\r\nFROM   spree_custom_products\r\nwhere updated_at > '@{variables('max_updated_date')}';",
									"type": "Expression"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobStorageWriteSettings"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_Intermiadate_Result",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Copy data1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_offline_product_cdc",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source1": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Delete1",
						"type": "Delete",
						"dependsOn": [
							{
								"activity": "Data flow1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "DS_Intermiadate_Result",
								"type": "DatasetReference",
								"parameters": {}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobStorageReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"max_updated_date": {
						"type": "String"
					}
				},
				"folder": {
					"name": "Product DB CDC"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/option_type')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "select sot.id, \n\tsott1.name as name_en,\n\tcoalesce(sott2.name,'') as name_ar,\n\tcoalesce(sott1.presentation,'') as presentation_en,\n\tcoalesce(sott2.presentation,'') as presentation_ar,\n    sot.created_at,\n    sot.updated_at\n\t\nfrom spree_option_types sot\nleft join spree_option_type_translations sott1 on sot.id = sott1.spree_option_type_id\nand sott1.locale='en'\nleft join spree_option_type_translations sott2 on sot.id = sott2.spree_option_type_id\nand sott2.locale='ar';"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "name_en",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "name_en",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "name_ar",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "name_ar",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "presentation_en",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "presentation_en",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "presentation_ar",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "presentation_ar",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										}
									},
									{
										"source": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_PRODUCT_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "option_type"
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Product DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/option_value')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "SELECT sov.id,\n       coalesce(sovt1.name,'') as name,\n       position,\n\t   coalesce(sovt1.presentation,'') as presentation_en,\n       coalesce(sovt2.presentation,'') AS presentation_ar,\n       sov.option_type_id,\n       sov.created_at,\n       sov.updated_at\nFROM   spree_option_values sov\nleft join spree_option_value_translations sovt1\non sov.id = sovt1.spree_option_value_id and sovt1.locale='en'\nleft join spree_option_value_translations sovt2\non sov.id = sovt2.spree_option_value_id and sovt2.locale='ar';"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "option_type_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "option_type_id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "name",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "name",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "presentation_en",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "presentation_en",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "presentation_ar",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "presentation_ar",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "position",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "position",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										}
									},
									{
										"source": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_PRODUCT_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "option_value"
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Product DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/order')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "order db",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "1.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "SELECT distinct\n    so.id,\n    so.item_total,\n    so.total,\n    CASE\n        WHEN so.state='delivery' THEN 'delivered'\n        WHEN so.state='picking_and_staging_in_progress' THEN 'pending'\n        WHEN so.state='payment' THEN 'pending'\n        WHEN so.state='complete' THEN 'completed'\n        WHEN so.state='confirm' THEN 'pending'\n--         WHEN so.state='cart' THEN 'pending'\n        WHEN so.state='canceled' THEN 'customer_cancelled'\n    END AS status,\n    so.user_id,\n    so.completed_at,\n    so.bill_address_id,\n    so.ship_address_id,\n    so.payment_total,\n    so.created_at,\n    so.updated_at,\n    so.currency,\n    so.item_count,\n\tso.canceled_at as cancelled_at,\n    so.canceler_id as cancelled_by,\n\tCASE WHEN so.delivery_method='home_delivery' THEN 1\n\tWHEN so.delivery_method='store_pick_up' THEN 2\n\tELSE NULL END as delivery_option_id,\n\tc.cancel_reason,\n\te.city,\n    1 as language_id,\n\tCOALESCE(e.country_id,'1') as country_id,\n\tsp_max.payment_method_id as payment_option_id\n\t\nfrom spree_orders so\nLEFT JOIN spree_fulfilments c ON c.order_id = so.id\nLEFT JOIN spree_user_addresses d ON d.user_id = so.user_id AND d.default = 'true'\nLEFT JOIN spree_addresses e ON e.id = d.address_id\nLEFT JOIN LATERAL (\n    SELECT *\n    FROM spree_payments sp\n    LEFT JOIN spree_payment_methods spm ON spm.id = sp.payment_method_id\n    WHERE sp.order_id = so.id\n\t AND (\n\t\t (SELECT COUNT(*) FROM spree_payments WHERE order_id = so.id) <= 1 OR\n\t\tspm.type NOT IN ('Spree::Gateway::LoyaltyPoint', 'Spree::PaymentMethod::StoreCredit')\n\t )\n    ORDER BY sp.created_at DESC \n    LIMIT 1\n) sp_max ON true\nwhere so.state != 'cart'"
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobStorageWriteSettings",
									"copyBehavior": "FlattenHierarchy"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_Intermiadate_Result",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "order db",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "order",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source1": {},
									"city": {},
									"ordercancellationreason": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Delete1",
						"type": "Delete",
						"dependsOn": [
							{
								"activity": "Data flow1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "DS_Intermiadate_Result",
								"type": "DatasetReference",
								"parameters": {}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobStorageReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Order DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/order_address')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Lookup1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "select \n\tso.id as order_id,\n\tso.bill_address_id as address_id,\n\t'true' as is_bill_address,\n \tCOALESCE(sa.city,'') as city,\n \tCOALESCE(con.name,'') as country,\n    sdtrans.name as district, \n\t'other' as type,\n\tCONCAT(sa.address1, ' ', sa.address2) AS formatted_address,\n \tCOALESCE(sa.latitude,'0.0') as latitude,\n \tCOALESCE(sa.longitude,'0.0') as longitude,\n\tCASE \n        WHEN sa.zipcode ~ '^[0-9]+$' THEN CAST(sa.zipcode AS INT)\n        ELSE NULL\n    END as postal_code,\n\tso.special_instructions as delivery_instruction,\n\tso.created_at,\n\tso.updated_at\nfrom spree_orders so\nleft join spree_addresses sa on sa.id = so.bill_address_id\nleft join spree_countries con on con.id=sa.country_id\nleft join spree_districts dist on dist.id=sa.district_id \nleft join spree_district_translations sdtrans on sdtrans.spree_district_id = dist.id and sdtrans.locale='en'\nwhere so.state != 'cart'\n\nUNION ALL\n\nselect \n\tROW_NUMBER() over () as id,\n\tso.id as order_id,\n\tso.ship_address_id as address_id,\n\t'false' as is_bill_address,\n \tCOALESCE(sa.city,'') as city,\n \tCOALESCE(con.name,'') as country,\n    sdtrans.name as district, \n\t'other' as type,\n\tCONCAT(sa.address1, ' ', sa.address2) AS formatted_address,\n \tCOALESCE(sa.latitude,'0.0') as latitude,\n \tCOALESCE(sa.longitude,'0.0') as longitude,\n\tCASE \n        WHEN sa.zipcode ~ '^[0-9]+$' THEN CAST(sa.zipcode AS INT)\n        ELSE NULL\n    END as postal_code,\n\tso.special_instructions as delivery_instruction,\n\tso.created_at,\n\tso.updated_at\nfrom spree_orders so\nleft join spree_addresses sa on sa.id = so.ship_address_id\nleft join spree_countries con on con.id=sa.country_id\nleft join spree_districts dist on dist.id=sa.district_id\nleft join spree_district_translations sdtrans on sdtrans.spree_district_id = dist.id and sdtrans.locale='en'\nwhere so.state != 'cart'"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"parallelCopies": 5,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "order_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "order_id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "address_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "address_id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "is_bill_address",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "is_bill_address",
											"type": "Boolean",
											"physicalType": "boolean"
										}
									},
									{
										"source": {
											"name": "city",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "city",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "country",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "country",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "district",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "district",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "type",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "type",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "formatted_address",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "formatted_address",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "latitude",
											"type": "Double",
											"physicalType": "double precision"
										},
										"sink": {
											"name": "latitude",
											"type": "Double",
											"physicalType": "double precision"
										}
									},
									{
										"source": {
											"name": "longitude",
											"type": "Double",
											"physicalType": "double precision"
										},
										"sink": {
											"name": "longitude",
											"type": "Double",
											"physicalType": "double precision"
										}
									},
									{
										"source": {
											"name": "postal_code",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "postal_code",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "delivery_instruction",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "delivery_instruction",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										}
									},
									{
										"source": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": false,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_ORDER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "order_address"
								}
							}
						]
					},
					{
						"name": "Lookup1",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": "Alter sequence order_address_id_seq restart with 1;\nSelect 'Altering Sequence' as update;",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "DS_V2_ORDER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "order_address"
								}
							},
							"firstRowOnly": false
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Order DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/order_adjustment')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "select sa.id,\n\tsa.order_id,\n    sa.created_at,\n    sa.updated_at,\n    sa.source_id,\n    sa.adjustable_id,\n    sa.adjustment_reason_id as adjustable_reason_id,\n    sa.amount,\n    sa.promotion_code_id,\n    sa.eligible,\n    sa.included,\n    sa.finalized,\n    sa.free_sample,\n    substring(sa.source_type,8) as source_type,\n    sa.label,\n    substring(sa.adjustable_type,8) as adjustable_type\nfrom spree_adjustments sa\nleft join spree_orders so on sa.order_id = so.id and so.state !='cart'"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_ORDER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "order_adjustment"
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Order DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/order_cancellation_reason')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "order_cancellation_reason table",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "WITH RankedResults AS (\n    SELECT\n        cancel_reason,\n        created_at,\n        updated_at,\n        ROW_NUMBER() OVER (PARTITION BY cancel_reason ORDER BY created_at DESC) AS rn\n    FROM spree_fulfilments\n    WHERE cancel_reason IS NOT NULL\n)\nSELECT\n    ROW_NUMBER() OVER () AS id,\n    cancel_reason AS reason_en,\n    '' AS reason_ar,\n    true AS visible,\n    created_at,\n    updated_at\nFROM RankedResults\nWHERE rn = 1\nORDER BY id ASC;"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_ORDER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "order_cancellation_reason"
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Order DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/order_invoice_logs')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "order_invoice_logs",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "SELECT\n    id,\n    zatca_status,\n    zatca_issued_date,\n    zatca_signed_xml_url,\n    zatca_uuid,\n    zatca_invoice_hash,\n    zatca_response,\n    spree_invoice_id,  -- Assuming spree_invoice_id is a reference to the id column\n    created_at,\n    updated_at\nFROM\n    public.spree_invoice_logs;"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_ORDER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "order_invoice_logs"
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Order DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/order_invoices')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "SELECT\n    id,\n    order_id,\n    type,\n    public_id,\n    is_qr_generated,\n    is_pdf_generated,\n    meta,\n    created_at,\n    updated_at,\n    qr_file_name,\n    qr_content_type,\n    qr_file_size,\n    qr_updated_at,\n    pdf_file_name,\n    pdf_content_type,\n    pdf_file_size,\n    pdf_updated_at,\n    qr_data,\n    job_id,\n    zatca_status,\n    zatca_issued_date,\n    zatca_signed_xml_url,\n    zatca_uuid,\n    zatca_invoice_hash,\n    zatca_response\nFROM\n    public.spree_invoices;"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"parallelCopies": 8,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_ORDER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "order_invoices"
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Order DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/order_payment')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "SELECT\n    ROW_NUMBER() over () as id,\n    sp.order_id,\n    sp.response_code AS transaction_id,\n    sp.amount,\n    coalesce(so.currency,'') as currency,\n    sp.state AS status,\n    sp.payment_method_id AS payment_option_id,\n    sp.source_id,\n\t  ss.id as shipment_id,\n    substring(sp.source_type,8) AS source_type\nFROM \n    spree_payments sp\nleft JOIN spree_orders so ON so.id = sp.order_id\nLEFT JOIN spree_shipments ss on ss.order_id = so.id;"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "order_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "order_id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "transaction_id",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "transaction_id",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "amount",
											"type": "Decimal",
											"physicalType": "numeric"
										},
										"sink": {
											"name": "amount",
											"type": "Double",
											"physicalType": "double precision"
										}
									},
									{
										"source": {
											"name": "currency",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "currency",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "status",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "status",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "shipment_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "shipment_id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "payment_option_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "payment_option_id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "source_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "source_id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "source_type",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "source_type",
											"type": "String",
											"physicalType": "character varying"
										}
									},
									{
										"source": {
											"name": "id",
											"type": "Int64",
											"physicalType": "bigint"
										},
										"sink": {
											"name": "id",
											"type": "Int32",
											"physicalType": "integer"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_ORDER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "order_payment"
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Order DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/order_payment_refund')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "select \nsr.id,\nsp.order_id,\ncase \nwhen sr.transaction_id is not null then sr.transaction_id \nelse sp.response_code \nend as transaction_id,\nsr.created_at,\nsr.updated_at,\nsr.amount,\ncase \n\twhen sr.status='uncertain' then 'pending'\n\twhen sr.status='failed' then 'failed'\n\twhen sr.status='success' then 'approved'\n\telse ''\nEnd as status,\n'SAR' as currency,\n'' as type\nFrom spree_refunds sr\ninner join spree_payments sp on sp.id=sr.payment_id \nwhere sr.payment_id is not null;"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_ORDER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "order_payment_refund"
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Order DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/order_product')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [],
						"policy": {
							"timeout": "0.15:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "WITH delivery_instructions AS (\n    SELECT \n        sli.line_item_id,\n        CONCAT(\n            'Preferred Cut - ', COALESCE(spc.name, ''), '::', \n            STRING_AGG(CONCAT(' ', COALESCE(scp.name_en, ''), ' ', ROUND(sli.quantity / 1000.0, 2), ' ', 'kg'), ', '), \n            STRING_AGG(CONCAT(' ', COALESCE(scp.name_ar, ''), ' ', ROUND(sli.quantity / 1000.0, 2), ' ', 'kg'), ', ')\n        ) AS delivery_instruction\n    FROM spree_line_item_cut_patterns sli\n    LEFT JOIN spree_cut_patterns scp ON scp.id = sli.cut_pattern_id \n    LEFT JOIN spree_preferred_cuts spc ON spc.id = scp.preferred_cut_id\n    WHERE sli.quantity > 0\n    GROUP BY sli.line_item_id, spc.name\n    ORDER BY sli.line_item_id\n)\nSELECT \n    sli.id,\n    sli.variant_id AS product_variant_id,\n    coalesce(CASE \n        WHEN  sv.weight_increment > 0 AND sv.default_weight_count > 0 AND sv.max_weight_per_order > 0 -- weighted product \n        then\n          case\n           when sli.requested_quantity < sv.weight_increment and sli.requested_quantity >0\n           \tthen sv.weight_increment  / sli.requested_quantity\n            else sli.requested_quantity /sv.weight_increment \n            end\n        ELSE sli.requested_quantity \n    END,0) AS quantity,\n    -- Determine picked_weight based on conditions\n    CASE \n        WHEN  sv.weight_increment > 0 AND sv.default_weight_count > 0 AND sv.max_weight_per_order > 0 -- weighted product \n        THEN sli.quantity \n        ELSE NULL\n    END AS picked_weight,\n    -- Determine picked_quantity based on conditions\n    COALESCE(\n        CASE \n            WHEN sv.weight_increment > 0 AND sv.default_weight_count > 0 AND sv.max_weight_per_order > 0\n                THEN 1\n                ELSE sli.quantity\n        END, 0\n    ) AS picked_quantity,\n    sli.price,\n    sli.created_at,\n    sli.replaced,\n    so.state,\n    COALESCE(sli.updated_at, CURRENT_TIMESTAMP) AS updated_at,\n    CASE \n        WHEN sli.on_sale = false THEN sli.price\n        ELSE '0.0'\n    END AS action_price,\n    CASE \n        WHEN sli.on_sale = true THEN sli.price\n        ELSE '0'\n    END AS sale_price,\n    0 AS picker_id,\n    sv.product_id,\n    di.delivery_instruction,\n    sli.order_id AS order_shipment_id,\n    CASE\n        WHEN so.replace_product::varchar = 'true' THEN 'replace-with-similar-product' \n        WHEN so.replace_product::varchar = 'false' THEN 'cancel'\n        ELSE NULL\n    END AS replacement_pref,\n    1 AS category_id,\n    '' AS status\nFROM spree_line_items sli\nLEFT JOIN spree_variants sv ON sv.id = sli.variant_id\nLEFT JOIN spree_orders so ON so.id = sli.order_id\nLEFT JOIN delivery_instructions di ON sli.id = di.line_item_id\n-- left join spree_product_translations spt on spt.spree_product_id = sv.product_id and spt.locale = 'en'\nWHERE so.state != 'cart'\norder by sli.id desc;"
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobStorageWriteSettings",
									"copyBehavior": "PreserveHierarchy"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"parallelCopies": 8,
							"dataIntegrationUnits": 4,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "id",
											"type": "Int32",
											"physicalType": "INT_32"
										}
									},
									{
										"source": {
											"name": "product_variant_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "product_variant_id",
											"type": "Int32",
											"physicalType": "INT_32"
										}
									},
									{
										"source": {
											"name": "quantity",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "quantity",
											"type": "Int32",
											"physicalType": "INT_32"
										}
									},
									{
										"source": {
											"name": "picked_weight",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "picked_weight",
											"type": "Int32",
											"physicalType": "INT_32"
										}
									},
									{
										"source": {
											"name": "picked_quantity",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "picked_quantity",
											"type": "Int32",
											"physicalType": "INT_32"
										}
									},
									{
										"source": {
											"name": "price",
											"type": "Decimal",
											"physicalType": "numeric"
										},
										"sink": {
											"name": "price",
											"type": "Decimal",
											"physicalType": "DECIMAL"
										}
									},
									{
										"source": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "INT_96"
										}
									},
									{
										"source": {
											"name": "replaced",
											"type": "Boolean",
											"physicalType": "boolean"
										},
										"sink": {
											"name": "replaced",
											"type": "Boolean",
											"physicalType": "BOOLEAN"
										}
									},
									{
										"source": {
											"name": "state",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "state",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp with time zone"
										},
										"sink": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "INT_96"
										}
									},
									{
										"source": {
											"name": "action_price",
											"type": "Decimal",
											"physicalType": "numeric"
										},
										"sink": {
											"name": "action_price",
											"type": "Decimal",
											"physicalType": "DECIMAL"
										}
									},
									{
										"source": {
											"name": "sale_price",
											"type": "Decimal",
											"physicalType": "numeric"
										},
										"sink": {
											"name": "sale_price",
											"type": "Decimal",
											"physicalType": "DECIMAL"
										}
									},
									{
										"source": {
											"name": "picker_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "picker_id",
											"type": "Int32",
											"physicalType": "INT_32"
										}
									},
									{
										"source": {
											"name": "product_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "product_id",
											"type": "Int32",
											"physicalType": "INT_32"
										}
									},
									{
										"source": {
											"name": "delivery_instruction",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "delivery_instruction",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "order_shipment_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "order_shipment_id",
											"type": "Int32",
											"physicalType": "INT_32"
										}
									},
									{
										"source": {
											"name": "replacement_pref",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "replacement_pref",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "category_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "category_id",
											"type": "Int32",
											"physicalType": "INT_32"
										}
									},
									{
										"source": {
											"name": "status",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "status",
											"type": "String",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_Intermiadate_Result",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Lookup1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "order_product",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"extractorderproduct": {},
									"ordershipment": {},
									"writestatusbacktodb": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Delete1",
						"type": "Delete",
						"dependsOn": [
							{
								"activity": "Data flow1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "DS_Intermiadate_Result",
								"type": "DatasetReference",
								"parameters": {}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobStorageReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							}
						}
					},
					{
						"name": "Lookup1",
						"type": "Lookup",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [
							{
								"activity": "Copy data1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": "Alter sequence order_product_id_seq restart with 1;\nSelect 'Reset Sequence ID' As Update;",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "DS_V2_ORDER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "order_product"
								}
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Order DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/order_promotions')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "select * from spree_orders_promotions;"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "order_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "order_id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "promotion_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "promotion_id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "promotion_code_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "promotion_code_id",
											"type": "Int32",
											"physicalType": "integer"
										}
									},
									{
										"source": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										}
									},
									{
										"source": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_ORDER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "order_promotions"
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Order DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/order_shipment')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "WITH cte AS (\n    SELECT  \n        so.id AS id,                        -- shipment_id \n        so.id AS order_id,\n        CASE\n            WHEN so.state = 'delivery' THEN 'delivered'\n            WHEN so.state = 'picking_and_staging_in_progress' THEN 'pending'\n            WHEN so.state = 'payment' THEN 'pending'\n            WHEN so.state = 'complete' THEN 'completed'\n            WHEN so.state = 'confirm' THEN 'pending'\n            WHEN so.state = 'canceled' THEN 'customer_cancelled'\n        END AS order_status,\n        so.created_at,\n        so.updated_at,\n        CAST((so.total * (so.vat_percentage / 100)) AS DOUBLE PRECISION) AS tax_total,\n        so.total,\n\t\tcast(dsto.start_time as text) as start_time, \n        cast(dsto.end_time as text) as end_time, \n\t\tCASE\n\t\t\tWHEN dtss.day_of_week = 0 THEN 'sunday'\n\t\t\tWHEN dtss.day_of_week = 1 THEN 'monday'\n\t\t\tWHEN dtss.day_of_week = 2 THEN 'tuesday'\n\t\t\tWHEN dtss.day_of_week = 3 THEN 'wednesday'\n\t\t\tWHEN dtss.day_of_week = 4 THEN 'thursday'\n\t\t\tWHEN dtss.day_of_week = 5 THEN 'friday'\n\t\t\tWHEN dtss.day_of_week = 6 THEN 'saturday'\n\t\t\tElse 'sunday'\n\t\tEND AS day_of_week,\n\t\tdtss.spree_shipping_method_id as delivery_option_id,\n        so.order_type,\n        so.supermarket_id,\n        sla.delivery_date,\n        sa.amount AS delivery_charges,\n        FALSE AS is_delivery_on_hold,\n        so.created_at AS processing_start_at,\n        ROW_NUMBER() OVER (PARTITION BY so.id ORDER BY so.id) AS row_num\n    FROM spree_orders so\n    LEFT JOIN danube_slot_to_orders dsto ON dsto.order_id = so.id\n\tleft join danube_time_slots_schedules dtss on dtss.id = dsto.time_slots_schedule_id\n    LEFT JOIN spree_lift_assignments sla ON sla.order_id = so.id\n    LEFT JOIN spree_adjustments sa ON sa.order_id = so.id AND sa.label = 'Express Fee'\n    WHERE so.state != 'cart'\n)\nSELECT *\nFROM cte\nWHERE row_num = 1;"
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobStorageWriteSettings",
									"copyBehavior": "FlattenHierarchy"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "id",
											"type": "Int32",
											"physicalType": "INT_32"
										}
									},
									{
										"source": {
											"name": "order_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "order_id",
											"type": "Int32",
											"physicalType": "INT_32"
										}
									},
									{
										"source": {
											"name": "order_status",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "order_status",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "created_at",
											"type": "DateTime",
											"physicalType": "INT_96"
										}
									},
									{
										"source": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "updated_at",
											"type": "DateTime",
											"physicalType": "INT_96"
										}
									},
									{
										"source": {
											"name": "tax_total",
											"type": "Double",
											"physicalType": "double precision"
										},
										"sink": {
											"name": "tax_total",
											"type": "Double",
											"physicalType": "DOUBLE"
										}
									},
									{
										"source": {
											"name": "total",
											"type": "Decimal",
											"physicalType": "numeric"
										},
										"sink": {
											"name": "total",
											"type": "Decimal",
											"physicalType": "DECIMAL"
										}
									},
									{
										"source": {
											"name": "start_time",
											"type": "TimeSpan",
											"physicalType": "time without time zone"
										},
										"sink": {
											"name": "start_time",
											"type": "TimeSpan",
											"physicalType": "INT_96"
										}
									},
									{
										"source": {
											"name": "end_time",
											"type": "TimeSpan",
											"physicalType": "time without time zone"
										},
										"sink": {
											"name": "end_time",
											"type": "TimeSpan",
											"physicalType": "INT_96"
										}
									},
									{
										"source": {
											"name": "day_of_week",
											"type": "String",
											"physicalType": "text"
										},
										"sink": {
											"name": "day_of_week",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "delivery_option_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "delivery_option_id",
											"type": "Int32",
											"physicalType": "INT_32"
										}
									},
									{
										"source": {
											"name": "order_type",
											"type": "String",
											"physicalType": "character varying"
										},
										"sink": {
											"name": "order_type",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "supermarket_id",
											"type": "Int32",
											"physicalType": "integer"
										},
										"sink": {
											"name": "supermarket_id",
											"type": "Int32",
											"physicalType": "INT_32"
										}
									},
									{
										"source": {
											"name": "delivery_date",
											"type": "DateTime",
											"physicalType": "date"
										},
										"sink": {
											"name": "delivery_date",
											"type": "DateTime",
											"physicalType": "INT_96"
										}
									},
									{
										"source": {
											"name": "delivery_charges",
											"type": "Decimal",
											"physicalType": "numeric"
										},
										"sink": {
											"name": "delivery_charges",
											"type": "Decimal",
											"physicalType": "DECIMAL"
										}
									},
									{
										"source": {
											"name": "is_delivery_on_hold",
											"type": "Boolean",
											"physicalType": "boolean"
										},
										"sink": {
											"name": "is_delivery_on_hold",
											"type": "Boolean",
											"physicalType": "BOOLEAN"
										}
									},
									{
										"source": {
											"name": "processing_start_at",
											"type": "DateTime",
											"physicalType": "timestamp without time zone"
										},
										"sink": {
											"name": "processing_start_at",
											"type": "DateTime",
											"physicalType": "INT_96"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_Intermiadate_Result",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Copy data1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "order_shipment",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"ordershipment": {},
									"deliverytype": {},
									"timeslottable": {},
									"writeintodb": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Delete1",
						"type": "Delete",
						"dependsOn": [
							{
								"activity": "Data flow1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "DS_Intermiadate_Result",
								"type": "DatasetReference",
								"parameters": {}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobStorageReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Order DB"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/payment_option')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "payment_option",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "PostgreSqlV2Source",
								"query": "SELECT id,\n       name,\n       created_at,\n       updated_at,\n       deleted_at,\n       CASE\n            WHEN type = 'Spree::PaymentMethod::StoreCredit' THEN 'e-wlt'\n            WHEN type = 'Spree::Gateway::PayFort' THEN 'credit'\n            WHEN type = 'Spree::Gateway::CheckoutCom' THEN 'credit'\n            WHEN type = 'Spree::Gateway::Tamara' THEN 'tamara'\n            WHEN type = 'Spree::Gateway::BogusSimple' THEN 'bogus-simple'\n            WHEN type = 'Spree::PaymentMethod::Check' THEN 'cod'\n            WHEN type = 'Spree::Gateway::CheckoutCom::ApplePay' THEN 'a-pay'\n            WHEN type = 'Spree::Gateway::LoyaltyPoint' THEN 'loy-pts'\n            WHEN type = 'Spree::Gateway::PayFort::ApplePay' THEN 'a-pay'\n        Else '' \n\t\tEnd as code\nFROM   spree_payment_methods\nwhere name is not null\nORDER  BY id ASC;"
							},
							"sink": {
								"type": "AzurePostgreSQLSink",
								"writeBatchSize": 1000000,
								"writeBatchTimeout": "00:30:00",
								"writeMethod": "CopyCommand"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "DS_V1_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_V2_USER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "payment_option"
								}
							}
						]
					},
					{
						"name": "Alter Sequence ID",
						"type": "Lookup",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [
							{
								"activity": "payment_option",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": "DO $$\nDECLARE\n    max_id INT;\nBEGIN\n    -- Step 1: Get the maximum id from the 'order' table\n    SELECT MAX(id) INTO max_id FROM \"payment_option\";\n    \n    -- Step 2: Alter the sequence to restart with max_id + 1\n    EXECUTE 'ALTER SEQUENCE payment_option_id_seq RESTART WITH ' || (max_id + 1000);\nEND $$;\nSelect 'Altering Sequence ID' as Update;",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "DS_V2_USER_DB_PRODUCTION",
								"type": "DatasetReference",
								"parameters": {
									"table_name": "payment_option"
								}
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "User DB"
				},
				"annotations": []
			},
			"dependsOn": []
		}
	]
}